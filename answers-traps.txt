问题1：通过之前的阅读学习可知，调用函数时的参数传递使用寄存器a1, a2等通用寄存器。通过阅读call.asm文件中的main函数可知，调用printf函数时，13被寄存器a2保存。
问题2：这里并没有看到显式调用f函数的跳转指令（例如jal或jalr），这意味着f函数可能已经被内联到main函数中。同样地，这里并没有看到显式调用g函数的跳转指令（例如jal或jalr），这意味着g函数也可能已经被内联到f函数中。
问题3：在0x65a。
问题4：在main函数中执行jalr到printf之后，寄存器ra中的值将是jalr指令之后的下一条指令的地址。根据汇编代码,执行这条jalr指令后，ra寄存器将保存返回地址，也就是下一条指令的地址，即0x38。因此，ra寄存器在jalr到printf之后的值是0x38。
问题5：运行结果是 He110 World。原理如下。57616转换为16进制为e110，所以格式化描述符%x打印出了它的16进制值。在小端（little-endian）处理器中，数据0x00646c72的高字节存储在内存的高位，那么从内存低位也就是低字节开始读取，72 6c 64 00对应的ASCII字符为r l d \0。为了在大端序系统上得到相同的输出，我们需要将i设置为0x726c6400，这样在大端序系统上i的存储顺序是72 6c 64 00，与小端序系统的结果相同。不需要更改57616的值，因为它在程序中作为一个十进制整数常量，其显示形式与端序无关。
问题6：printf语句中有两个格式说明符%d，但只传递了一个参数3。由于缺少一个参数，printf会从栈中读取一个未定义的值作为第二个%d的参数。这会导致y=后面打印一个未定义的值，即一个随机的整数。这是因为printf试图从栈中读取第二个参数，而实际上没有提供第二个参数，所以它会使用栈上已有的随机数据。

